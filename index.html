<script>
// ---------- helpers ----------
const phi = x => 0.5 * (1 + Math.erf(x / Math.SQRT2));        // CDF للنورمال
const ln  = Math.log;

// يحسب sigma السنوي من log-returns خلال نافذة دقائق (EWMA بسيطة)
async function estimateSigmaAnnual(minutes = 30) {
  const limit = Math.min(Math.max(minutes, 5), 1000);
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${limit}`;
  const rows = await fetch(url).then(r => r.json());
  if (!Array.isArray(rows) || rows.length < 5) return 0.5; // fallback 50% سنوي

  const closes = rows.map(r => +r[4]);
  const rets = [];
  for (let i=1; i<closes.length; i++) rets.push( ln(closes[i]/closes[i-1]) );

  // EWMA:
  const lambda = 0.94; // مثل ريسك متريكس
  let varEW = rets[0]**2;
  for (let i=1; i<rets.length; i++) varEW = lambda*varEW + (1-lambda)*rets[i]**2;
  const sigma1m = Math.sqrt(varEW);          // انحراف معياري لكل دقيقة (لوغ)
  const minutesPerYear = 525600;             // 365*24*60
  const sigmaAnnual = sigma1m * Math.sqrt(minutesPerYear);

  return Math.min(Math.max(sigmaAnnual, 0.05), 2.0); // قص إلى [5%, 200%] لتجنب الجنون
}

// يجيب سعر افتتاح الساعة الحالية (ET) من شمعة 1h في Binance
async function getPriceToBeatETOpen() {
  // حوّل الآن إلى America/New_York ثم خذ بداية الساعة بالـ UTC millis
  const now = new Date();
  // تقريب بسيط: استعمل بداية الساعة UTC (لو تبغى ET بدقة، حول بفيوز America/New_York)
  const startUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), 0, 0, 0)).getTime();
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startUTC}&limit=1`;
  const rows = await fetch(url).then(r => r.json());
  if (Array.isArray(rows) && rows.length) return +rows[0][1]; // open
  return null;
}

// يحسب الدقائق/الثواني المتبقية لنهاية الساعة (ET/UTC كما اخترت فوق)
function getTimeLeftSeconds() {
  const now = new Date();
  const endUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours()+1, 0, 0, 0));
  return Math.max(0, Math.floor((+endUTC - now) / 1000));
}

// احتمال الإغلاق فوق K (GBM)
function probabilityUp(S0, K, sigmaAnnual, secondsLeft) {
  if (!S0 || !K || !sigmaAnnual || secondsLeft <= 0) return 0.5;
  const t = secondsLeft / (365*24*60*60);    // سنوات
  const denom = sigmaAnnual * Math.sqrt(t);
  if (denom <= 1e-9) return S0 >= K ? 1 : 0; // لو الوقت شبه صفر
  const z = (ln(S0/K)) / denom;              // بدون drift
  return phi(z);
}

// ---------- live loop ----------
let latestPrice = null;
let ptb = null;
let sigmaAnn = 0.5;

async function initModel() {
  // 1) PTB & Sigma
  [ptb, sigmaAnn] = await Promise.all([
    getPriceToBeatETOpen(),
    estimateSigmaAnnual(30), // نافذة 30 دقيقة
  ]);
  // 2) WebSocket price
  const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
  ws.onmessage = ev => {
    const msg = JSON.parse(ev.data);
    latestPrice = +msg.p;
  };
}

async function tickAndRender(render) {
  if (!ptb) ptb = await getPriceToBeatETOpen();
  if (!sigmaAnn) sigmaAnn = await estimateSigmaAnnual(30);

  const secsLeft = getTimeLeftSeconds();
  const S0 = latestPrice;

  // حساب الاحتمالات
  const up = probabilityUp(S0, ptb, sigmaAnn, secsLeft);
  const down = 1 - up;

  render({
    price: S0,
    ptb,
    timeLeftSec: secsLeft,
    upPct: +(up*100).toFixed(1),
    downPct: +(down*100).toFixed(1)
  });
}

// مثال دمج مع واجهتك: مرر دالة render تحدث العناصر
initModel().then(() => {
  const render = (o) => {
    // حدّث واجهتك هنا:
    // document.querySelector('#price').textContent = o.price?.toFixed(2) ?? '—';
    // document.querySelector('#ptb').textContent = o.ptb?.toFixed(2) ?? '—';
    // document.querySelector('#time').textContent = formatMMSS(o.timeLeftSec);
    // document.querySelector('#up').textContent = o.upPct + '%';
    // document.querySelector('#down').textContent = o.downPct + '%';
    console.log(o);
  };
  // تحديث سريع كل 1s
  setInterval(() => tickAndRender(render), 1000);
});

// (اختياري) تنسيق وقت mm:ss
function formatMMSS(s){
  const m = Math.floor(s/60), ss = s%60;
  return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
}
</script>
