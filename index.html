<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BTC Up/Down — Black–Scholes</title>
<link rel="manifest" href="manifest.json"/>
<meta name="theme-color" content="#0b0f1a"/>
<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<style>
  :root{
    --bg:#0b0f1a; --card:#121826; --ink:#e7eaf0; --muted:#97a1b3;
    --pos:#22c55e; --neg:#ef4444; --accent:#3b82f6;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font:500 16px ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
  }
  .wrap{max-width:800px; margin:0 auto; padding:20px 16px 40px; min-height:100%;}
  h1{margin:8px 0 6px; font-size:28px; letter-spacing:.4px}
  .sub{color:var(--muted); font-size:13px; margin-bottom:14px}
  .grid{display:grid; gap:12px}
  @media(min-width:520px){ .grid{grid-template-columns:1fr 1fr} }
  .row{
    background:var(--card); border-radius:14px; padding:14px 16px;
    display:flex; align-items:center; justify-content:space-between; min-height:64px;
  }
  .lbl{color:var(--muted); font-size:13px; letter-spacing:.3px}
  .val{font-weight:700; font-size:18px}
  .mono{font-variant-numeric:tabular-nums; font-feature-settings:"tnum" 1}
  .val.pos{color:var(--pos)} .val.neg{color:var(--neg)}
  .foot{margin-top:16px; color:var(--muted); font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>BTC Up/Down — Black–Scholes</h1>
    <div class="sub">Live from Binance · Hour window (ET)</div>

    <div class="grid">
      <div class="row"><div class="lbl">PRICE</div>            <div id="priceVal"    class="val mono">—</div></div>
      <div class="row"><div class="lbl">PRICE TO BEAT</div>     <div id="ptbVal"      class="val mono">—</div></div>
      <div class="row"><div class="lbl">TIME LEFT</div>         <div id="timeLeftVal" class="val mono">—</div></div>
      <div class="row"><div class="lbl">GAP TO BEAT ($)</div>   <div id="gapVal"      class="val mono">—</div></div>
      <div class="row"><div class="lbl">EXPECTED MOVE ($)</div> <div id="emVal"       class="val mono">—</div></div>
      <div class="row"><div class="lbl">STRENGTH (%)</div>      <div id="strengthVal" class="val mono">—</div></div>
      <div class="row"><div class="lbl">UP %</div>              <div id="upVal"       class="val mono">—</div></div>
      <div class="row"><div class="lbl">DOWN %</div>            <div id="downVal"     class="val mono">—</div></div>
    </div>

    <div id="stamp" class="foot">—</div>
    <div class="foot">WebSocket: Binance · REST: 1m/1h (klines) · TZ: America/New_York (ET)</div>
  </div>

<script>
const {DateTime} = luxon;

// ===== تنسيقات =====
const fmt2 = x => Number.isFinite(x) ? x.toFixed(2) : '—';
const pct1 = x => Number.isFinite(x) ? x.toFixed(1)+'%' : '—';

// ===== نافذة الساعة بتوقيت نيويورك =====
function getETWindow(){
  const nowET   = DateTime.now().setZone('America/New_York');
  const startET = nowET.startOf('hour');
  const endET   = startET.plus({hours:1});
  const secsLeft = Math.max(0, Math.floor(endET.diff(nowET, 'seconds').seconds));
  return { startMsUTC: startET.toUTC().toMillis(), secsLeft };
}

// ===== Binance: PTB (افتتاح شمعة 1h) =====
async function fetchPTB(startMsUTC){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${startMsUTC}&limit=1`;
  const r = await fetch(url); const j = await r.json();
  if(Array.isArray(j) && j.length) return parseFloat(j[0][1]); // open
  return NaN;
}

// ===== Binance: تقلب 1m (Realized) =====
async function fetchRealizedVol1m(n=60){
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${Math.max(10,Math.min(1000,n))}`;
  const r = await fetch(url); const d = await r.json();
  if(!Array.isArray(d) || d.length < 10) return { sigma1m: 0.0015, lastClose: NaN };
  const closes = d.map(c => +c[4]);
  const rets = [];
  for(let i=1;i<closes.length;i++){
    const rr = Math.log(closes[i]/closes[i-1]);
    if(Number.isFinite(rr)) rets.push(rr);
  }
  if(rets.length < 5) return { sigma1m: 0.0015, lastClose: closes.at(-1) };
  const mean = rets.reduce((a,b)=>a+b,0)/rets.length;
  const varr = rets.reduce((a,b)=>a+(b-mean)*(b-mean),0)/(rets.length-1);
  const sigma1m = Math.sqrt(Math.max(varr, 1e-12)); // stddev لكل دقيقة (لوغ)
  return { sigma1m, lastClose: closes.at(-1) };
}

// ===== CDF طبيعي قياسي =====
function phiCDF(z){
  const t = 1/(1+0.2316419*Math.abs(z));
  const d = 0.3989422804014327*Math.exp(-0.5*z*z);
  const p = d*t*(0.319381530 + t*(-0.356563782 + t*(1.781477937 + t*(-1.821255978 + t*1.330274429))));
  return z>=0 ? 1-p : p;
}

// ===== Strength: خطي 0↔100 مع 50% عند gap=0 =====
function computeStrength(gap, EM){
  if(!Number.isFinite(gap) || !Number.isFinite(EM) || EM<=0) return 50;
  let ratio = gap / EM; // -1 ↔ +1 عندما gap=±EM
  ratio = Math.max(-1, Math.min(1, ratio));
  return (ratio + 1) * 50; // [-1,1] → [0,100]
}

// ===== Expected Move بالدولار من sigma1m والزمن المتبقي =====
function computeExpectedMoveUSD(S, secsLeft, sigma1m){
  const sigma1s = sigma1m / Math.sqrt(60);         // stddev لكل ثانية (لوغ)
  const em = S * sigma1s * Math.sqrt(Math.max(secsLeft,1));
  return Math.max(em, 0.5); // حد أدنى
}

// ===== احتمالات Black–Scholes عبر N(d2) مع أخذ الوقت المتبقي =====
function bsProbUpDown(S, K, sigma1m, secsLeft){
  const EPS=1e-12, yearSecs = 365*24*3600;
  if(!(S>0 && K>0 && sigma1m>0 && secsLeft>=1)) return { pUp:0.5, pDown:0.5, d2:NaN };

  // سنويّة التقلب من σ_1m → σ_1s → σ_annual
  const sigma1s = sigma1m/Math.sqrt(60);
  const sigma   = sigma1s * Math.sqrt(yearSecs); // تقلب سنوي (لوغ)

  const T = Math.max(secsLeft,1) / yearSecs;     // بالسنوات
  const denom = sigma * Math.sqrt(T);
  if(denom < EPS){
    const pUp = S>=K ? 1 : 0; return {pUp, pDown:1-pUp, d2: (S>=K?Infinity:-Infinity)};
  }
  const d2 = (Math.log(S/K) - 0.5*sigma*sigma*T) / denom;

  // ملاحظة: P(S_T > K) = N(d2) تحت الحياد للمخاطر
  const pUp = phiCDF(d2);
  return { pUp, pDown: 1-pUp, d2 };
}

// ===== الحالة و ربط العناصر =====
const el = id => document.getElementById(id);
const $price=el('priceVal'), $ptb=el('ptbVal'), $time=el('timeLeftVal'),
      $gap=el('gapVal'), $em=el('emVal'), $str=el('strengthVal'),
      $up=el('upVal'), $down=el('downVal'), $stamp=el('stamp');

let state = {
  price: NaN, ptb: NaN, secsLeft: 0,
  sigma1m: 0.0015,   // stddev دقيقة (لوغ) كبداية
  lastVolUpdate: 0
};

function fmtTime(secs){
  const m = Math.floor(secs/60);
  const s = secs%60;
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

function paintGap(valEl, gap){
  valEl.classList.remove('pos','neg');
  if (gap>0){ valEl.classList.add('pos'); valEl.textContent = `+${fmt2(gap)}`; }
  else if (gap<0){ valEl.classList.add('neg'); valEl.textContent = `${fmt2(gap)}`; }
  else { valEl.textContent = fmt2(0); }
}

function updateUI(){
  // وقت متبقي
  const {secsLeft} = getETWindow();
  state.secsLeft = secsLeft;
  $time.textContent = fmtTime(secsLeft);

  // EM و Gap و Strength
  const EM = computeExpectedMoveUSD(state.price, state.secsLeft, state.sigma1m);
  $em.textContent = fmt2(EM);

  const gap = state.price - state.ptb;
  paintGap($gap, gap);

  const strengthPct = computeStrength(gap, EM);
  $str.textContent = pct1(strengthPct);
  $str.classList.remove('pos','neg');
  $str.classList.add(gap>=0?'pos':'neg');

  // احتمالات Black–Scholes
  const {pUp, pDown} = bsProbUpDown(state.price, state.ptb, state.sigma1m, state.secsLeft);
  $up.textContent   = pct1(pUp*100);
  $down.textContent = pct1(pDown*100);
  $up.classList.toggle('pos', pUp>=0.5);  $up.classList.toggle('neg', pUp<0.5);
  $down.classList.toggle('neg', pDown>=0.5); $down.classList.toggle('pos', pDown<0.5);

  // ختم
  const now = new Date().toISOString().replace('T',' ').slice(0,19);
  $stamp.textContent = `Last update: ${now} UTC`;
}

// تحديث PTB و Vol
async function refreshPTBandVol(){
  const {startMsUTC, secsLeft} = getETWindow();
  state.secsLeft = secsLeft;

  // PTB
  try{
    const ptb = await fetchPTB(startMsUTC);
    if(Number.isFinite(ptb)){ state.ptb = ptb; $ptb.textContent = fmt2(ptb); }
  }catch(e){ /* ignore */ }

  // Vol 1m
  try{
    const {sigma1m, lastClose} = await fetchRealizedVol1m(60);
    if(Number.isFinite(sigma1m)) { state.sigma1m = sigma1m; }
    if(Number.isFinite(lastClose) && !Number.isFinite(state.price)){
      state.price = lastClose; $price.textContent = fmt2(state.price);
    }
  }catch(e){ /* ignore */ }

  updateUI();
}

// WebSocket للسعر
function startWS(){
  try{
    const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
    ws.onmessage = ev=>{
      const msg = JSON.parse(ev.data);
      const p = parseFloat(msg.p);
      if(Number.isFinite(p)){
        state.price = p;
        $price.textContent = fmt2(p);
        updateUI();
      }
    };
    ws.onclose = ()=> setTimeout(startWS, 3000);
    ws.onerror = ()=> { try{ ws.close(); }catch{} };
  }catch(e){
    // Fallback REST كل 3 ثوانٍ
    setInterval(async ()=>{
      try{
        const r = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');
        const j = await r.json(); const p = parseFloat(j.price);
        if(Number.isFinite(p)){ state.price = p; $price.textContent = fmt2(p); updateUI(); }
      }catch(_){}
    }, 3000);
  }
}

(async function init(){
  await refreshPTBandVol();
  startWS();
  setInterval(updateUI, 1000);       // تحديث واجهة كل ثانية
  setInterval(refreshPTBandVol, 30000); // إعادة جلب PTB & Vol كل 30 ثانية
})();
</script>
</body>
</html>
